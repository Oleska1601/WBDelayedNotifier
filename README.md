# DelayedNotifier — отложенные уведомления через очереди

## Задание
Во многих сервисах пользователям нужно напоминать о чём-то не сразу, а через какое-то время. Это могут быть уведомления о предстоящих встречах, напоминания о заказе, сообщения в мессенджере или email через несколько часов, дней и т.д. Вручную такие вещи не отправляют — этим занимается отдельный сервис, который умеет «запоминать», когда и кому нужно отправить сообщение, и делает это автоматически.

В этом задании вам надо реализовать как раз такой сервис. Он будет принимать запросы на создание уведомлений, складывать их в очередь (через RabbitMQ), а затем — в нужное время — отправлять. Если что-то пошло не так, сервис попробует повторить отправку позже. Это типичный бэкенд-компонент, который может использоваться в CRM-системах, образовательных платформах, онлайн-магазинах и других проектах.

Требования
Cервис должен поддерживать:

встроенные HTTP-методы:
– POST /notify — создание уведомлений с датой и временем отправки;
– GET /notify/{id} — получение статуса уведомления;
– DELETE /notify/{id} — отмена запланированного уведомления.

фоновую обработку очереди уведомлений:
– уведомления должны отправляться в указанное время;
– в случае ошибки отправка должна повторяться (с экспоненциальной задержкой).

Дополнительно (будет плюсом):

использование Redis для кэширования и быстрой проверки статуса;

реализация отправки уведомлений через различные каналы (например, Email, Telegram);

простой UI (на любых технологиях — можно даже на HTML + JS без фреймворков) с формой для создания уведомления и отображением текущих уведомлений и их статусов. Это поможет протестировать сервис без ручных curl-запросов и наглядно увидеть, как он работает.

### Хранение в базе данных:
1. Статусы уведомлений
```sql
CREATE TYPE status AS ENUM
(
    'scheduled',    --создано, время еще не наступило
    'sent',         --отправлено
    'cancelled',    --отменено до отправки
    'failed'       --не удалось отправить после всех попыток
);
```
2. Канал отправки
```sql
CREATE TYPE channel AS ENUM
(
    'telegram',    
    'email'         
);
```

3. Таблица с уведомлениями
```

CREATE TABLE IF NOT EXISTS notifications (
    id SERIAL PRIMARY KEY,
    channel channel NOT NULL,
    recipient VARCHAR(255) NOT NULL,
    message VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL,                   --во сколько было создано
    scheduled_at TIMESTAMP WITH TIME ZONE NOT NULL,                 --на сколько была запланирована отправка
    sent_at TIMESTAMP WITH TIME ZONE,                               --во сколько реально отправилось (учитывая задержки и возможные retry, время проставится после отправки в указанный канал)
    status status NOT NULL 
);
```
P.s. данная модель является несколько упрощенной, но практичной для данного проекта.
В реальной системе можно было бы хранить таблицу users, сохраняв email и telegram пользователя туда, а сюда передавать user_id как foreign key


### Логика работы публикации уведомлений (Publisher)
- Система использует отложенные сообщения через RabbitMQ с плагином **rabbitmq_delayed_message_exchange**. Каждое уведомление публикуется с задержкой, равной разнице между временем создания и запланированным временем отправки.
- итоговое сообщение содержит ID уведомления (для последующего обновления статуса в случае успешной отправки), получателя и текст сообщения
- Сообщение публикуется в exchange с указанием routing key = каналу передачи, указанным пользователем при отправки (email / telegram)

### Логика работы принятия уведомлений и отправки по указанному пути (email/telegram) (Notifier)
- Система использует два типа воркеров для обработки уведомлений: основные воркеры для первоначальной доставки и ретрай-воркеры для повторных попыток отправки. Каждый тип канала доставки (Telegram, Email) имеет свои отдельные очереди.

**Схема**:
![alt text](<wb delayed.jpg>)

**Процесс**:
- при получении сообщения и успешном парсинге система проверяет текущий статус сообщения. Если пользователь успел отменить его (`status = cancelled`), то обработка сообщения завершается и оно гарантированно не будет доставлено
- далее происходит сама отправка по указанному каналу: если с первого раза сообщение доставить не получилось, оно переходит в **rabbitmq_delayed_message_exchange**, связанный непосредственно с retry очередями, с заданной экспоненциальной задержкой и теперь будет обрабатываться другими воркерами. 
- Цикл экспоненциальной задержки будет крутится макс 5 раз (опционально). Если сообщение так и не удасться отправить, в БД статус обновится на `failed`
- В случае успешной отправки статус в БД обновится на `sent` и установится время отправки в поле `sent_at`

Такой подход позволяет разделить обработку основных сообщений и retry - сообщений, позволяя основным воркерам не перегружаться, а сообщениям пытаться быть всё-таки доставленным до конечного пользователя


### Тестирование:
1. Через переменные окружения необходимо установить следующие параметры:
```
POSTGRES_USERNAME=
POSTGRES_PASSWORD=
POSTGRES_DB=
EMAIL_USERNAME=
EMAIL_PASSWORD=
EMAIL_FROM=

TELEGRAM_BOT_TOKEN=
```
TELEGRAM_BOT_TOKEN является не обязательным параметром, можно воспользоваться моим ботом (токен уже определен в `config.yaml`)

2. При успешной загрузке работу сервиса можно протестировать через UI по адресу `http://host:port`, указанным в `config.yaml`, или через swagger
3. Формат получения сообщения с фронта
```go
type CreateNotificationRequest struct {
	Channel     models.Channel `json:"channel" binding:"required,oneof=email telegram" example:"telegram"`
	Recipient   string         `json:"recipient" binding:"required" example:"796744183"` // код тг или email
	Message     string         `json:"message" validate:"required" example:"test_message"`
	ScheduledAt time.Time      `json:"scheduled_at" validate:"required" example:"2025-11-01T10:40:00Z"`
}
```
- в поле channel указывается желаемый формат получения уведомления
- в поле recipient клиент указывает код, который вышлется через бота после того, как он напишет ему /start
